<script>
(() => {
  // ===== PWA badge helper =====
  const installState = document.getElementById("installState");
  window.addEventListener("beforeinstallprompt", () => { installState.textContent = "Installable"; });
  window.addEventListener("appinstalled", () => { installState.textContent = "Installed"; });

  // ===== Tabs =====
  const tabBtns = Array.from(document.querySelectorAll(".tabbtn"));
  const tabs = {
    feed: document.getElementById("tab-feed"),
    reminders: document.getElementById("tab-reminders"),
    music: document.getElementById("tab-music"),
    history: document.getElementById("tab-history"),
  };

  function switchTab(name){
    for (const k of Object.keys(tabs)) tabs[k].classList.toggle("hide", k !== name);
    tabBtns.forEach(b => {
      const active = b.dataset.tab === name;
      b.classList.toggle("active", active);
      b.setAttribute("aria-selected", active ? "true" : "false");
    });
    window.scrollTo({ top: 0, behavior: "smooth" });
  }
  tabBtns.forEach(b => b.addEventListener("click", () => switchTab(b.dataset.tab)));

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);

  const clockTextEl = $("clockText");
  const sinceTimerEl = $("sinceTimer");
  const lastFeedTextEl = $("lastFeedText");
  const lastFeedShortEl = $("lastFeedShort");
  const runningTextEl = $("runningText");
  const todayCountEl = $("todayCount");
  const avgIntervalEl = $("avgInterval");
  const maxIntervalEl = $("maxInterval");

  const runningPill = $("runningPill");

  const noteEl = $("note");
  const listEl = $("list");
  const summaryBoxEl = $("summaryBox");

  const btnStart = $("btnStart");
  const btnLogNote = $("btnLogNote");
  const btnReset = $("btnReset");

  const qBreast = $("qBreast");
  const qFormula = $("qFormula");
  const qBurp = $("qBurp");
  const qNote = $("qNote");

  const btnClearToday = $("btnClearToday");
  const btnClearAll = $("btnClearAll");

  const btnGoReminders = $("btnGoReminders");
  const btnGoHistory = $("btnGoHistory");

  // Music UI
  const musicStateEl = $("musicState");
  const btnEnableSound = $("btnEnableSound");
  const btnMusicPlay = $("btnMusicPlay");
  const btnMusicPause = $("btnMusicPause");
  const btnMusicStop = $("btnMusicStop");
  const musicTrackEl = $("musicTrack");
  const musicLoopEl = $("musicLoop");
  const musicVolEl = $("musicVol");

  // Alarm UI
  const notifPill = $("notifPill");
  const oneShotMinsEl = $("oneShotMins");
  const oneShotEnabledEl = $("oneShotEnabled");
  const repeatMinsEl = $("repeatMins");
  const repeatEnabledEl = $("repeatEnabled");
  const soundModeEl = $("soundMode");
  const soundModeTextEl = $("soundModeText");

  const btnSaveAlarm = $("btnSaveAlarm");
  const btnEnableNotif = $("btnEnableNotif");
  const btnTestAlarm = $("btnTestAlarm");
  const btnStopAlarm = $("btnStopAlarm");

  const nextOneShotTextEl = $("nextOneShotText");
  const nextRepeatTextEl = $("nextRepeatText");

  // Overlay
  const alarmOverlay = $("alarmOverlay");
  const alarmTitleEl = $("alarmTitle");
  const alarmMsgEl = $("alarmMsg");
  const alarmMetaEl = $("alarmMeta");
  const btnOverlayStop = $("btnOverlayStop");
  const btnOverlaySnooze = $("btnOverlaySnooze");
  const btnOverlayDismiss = $("btnOverlayDismiss");

  // ===== Storage keys =====
  const LS_LOGS = "bf_logs_ui_v1";
  const LS_STATE = "bf_state_ui_v1";
  const LS_ALARM = "bf_alarm_ui_v1";
  const LS_MUSIC = "bf_music_ui_v1";

  // ===== State =====
  let running = false;
  let lastFeedAtMs = 0;
  let rafId = null;

  // Alarm settings
  let oneShotMins = 120;
  let oneShotEnabled = true;
  let repeatMins = 180;
  let repeatEnabled = false;
  let soundMode = "lullaby";

  // Alarm schedule
  let oneShotTimeoutId = null;
  let repeatTimeoutId = null;
  let nextOneShotAtMs = 0;
  let nextRepeatAtMs = 0;

  // Alarm sound (WebAudio)
  let audioCtx = null;
  let alarmActive = false;
  let activeNodes = [];
  let soundTimer = null;
  let audioUnlocked = false;

  // Wake lock (screen awake)
  let wakeLock = null;

  // Background music (HTMLAudio)
  const bgAudio = new Audio();
  bgAudio.preload = "auto";

  // ===== Helpers =====
  const pad = (n) => String(n).padStart(2, "0");

  const fmtHMS = (ms) => {
    const total = Math.max(0, Math.floor(ms / 1000));
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = total % 60;
    return `${pad(h)}:${pad(m)}:${pad(s)}`;
  };

  const escapeHtml = (str) =>
    String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");

  const loadJSON = (k, fallback) => {
    try { return JSON.parse(localStorage.getItem(k) || fallback); }
    catch { return JSON.parse(fallback); }
  };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));

  const toLocalDateKey = (ms) => {
    const d = new Date(ms);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  };

  const formatWhen = (ms) => ms ? new Date(ms).toLocaleString() : "—";
  const formatShort = (ms) => ms ? new Date(ms).toLocaleTimeString([], { hour: "2-digit", minute:"2-digit" }) : "—";

  function updateClock(){
    clockTextEl.textContent = new Date().toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }

  function setUI(){
    btnStart.disabled = running;
    btnLogNote.disabled = !running;
    btnReset.disabled = !running && !lastFeedAtMs;

    qBreast.disabled = !running;
    qFormula.disabled = !running;
    qBurp.disabled = !running;
    qNote.disabled = !running;

    runningTextEl.textContent = running ? "Yes" : "No";
    runningPill.textContent = running ? "Running" : "Stopped";
    runningPill.style.background = running ? "var(--goodSoft)" : "var(--primarySoft)";
    runningPill.style.color = running ? "var(--good)" : "var(--primary)";
    runningPill.style.borderColor = running ? "#cfeedd" : "#d6e4ff";

    lastFeedTextEl.textContent = lastFeedAtMs ? formatWhen(lastFeedAtMs) : "—";
    lastFeedShortEl.textContent = lastFeedAtMs ? formatShort(lastFeedAtMs) : "—";

    btnStopAlarm.disabled = !alarmActive;

    nextOneShotTextEl.textContent = formatWhen(nextOneShotAtMs);
    nextRepeatTextEl.textContent = formatWhen(nextRepeatAtMs);

    soundModeTextEl.textContent = (soundMode === "lullaby") ? "Lullaby" : "Beep";

    updateNotifPill();
    setMusicUI();
  }

  function getSinceMs(){
    if (!running || !lastFeedAtMs) return 0;
    return Date.now() - lastFeedAtMs;
  }

  function tick(){
    sinceTimerEl.textContent = fmtHMS(getSinceMs());
    rafId = requestAnimationFrame(tick);
  }

  // ===== Notifications =====
  function updateNotifPill(){
    if (!("Notification" in window)){
      notifPill.textContent = "Notif: Not supported";
      return;
    }

    // iOS Safari can be picky; show clearer label
    const p = Notification.permission || "default";
    notifPill.textContent = `Notif: ${p}`;
  }

  async function enableNotifications(){
    if (!("Notification" in window)){
      alert("Notifications are not supported on this browser. The app will still use the on-screen alarm + vibration.");
      return false;
    }

    try {
      const perm = await Notification.requestPermission();
      updateNotifPill();
      return perm === "granted";
    } catch {
      updateNotifPill();
      return false;
    }
  }

  function tryNotify(title, body){
    if (!("Notification" in window)) return;
    if (Notification.permission !== "granted") return;
    try { new Notification(title, { body, silent: false }); } catch {}
  }

  // ===== Wake Lock (keep screen awake where supported) =====
  async function enableWakeLock(){
    try {
      if ("wakeLock" in navigator && running) {
        wakeLock = await navigator.wakeLock.request("screen");
        wakeLock.addEventListener?.("release", () => {
          wakeLock = null;
        });
        return true;
      }
    } catch (e) {
      console.warn("Wake lock failed:", e);
    }
    return false;
  }

  async function releaseWakeLock(){
    try {
      if (wakeLock) {
        await wakeLock.release();
        wakeLock = null;
      }
    } catch {}
  }

  // ===== WebAudio alarm sound =====
  async function ensureAudio(){
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("WebAudio not supported");
      audioCtx = new Ctx();
    }
    if (audioCtx.state === "suspended") await audioCtx.resume();
    return audioCtx;
  }

  async function unlockAudio(){
    try{
      await ensureAudio();

      // Tiny ping to unlock audio on mobile
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      g.gain.value = 0.0001;
      osc.frequency.value = 440;
      osc.connect(g);
      g.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.05);

      osc.onended = () => {
        try { osc.disconnect(); } catch {}
        try { g.disconnect(); } catch {}
      };

      audioUnlocked = true;
      return true;
    } catch (e) {
      console.warn("unlockAudio failed:", e);
      audioUnlocked = false;
      return false;
    }
  }

  function stopAlarmNodes(){
    if (soundTimer) clearInterval(soundTimer);
    soundTimer = null;

    for (const n of activeNodes){
      try { n.stop?.(0); } catch {}
      try { n.disconnect?.(); } catch {}
    }
    activeNodes = [];
  }

  function clearAlarmAttention(){
    document.body.classList.remove("alarm-flash");
    try { navigator.vibrate?.(0); } catch {}
  }

  async function startBeep(){
    await ensureAudio();
    stopAlarmNodes();

    const gain = audioCtx.createGain();
    gain.gain.value = 0.0001;
    gain.connect(audioCtx.destination);
    activeNodes.push(gain);

    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.value = 880;
    osc.connect(gain);
    osc.start();
    activeNodes.push(osc);

    let on = false;
    let hi = true;

    soundTimer = setInterval(() => {
      if (!audioCtx) return;
      on = !on;
      hi = !hi;
      osc.frequency.setValueAtTime(hi ? 880 : 660, audioCtx.currentTime);
      gain.gain.setValueAtTime(on ? 0.35 : 0.0001, audioCtx.currentTime);
    }, 350);
  }

  async function startLullaby(){
    await ensureAudio();
    stopAlarmNodes();

    const seq = [523.25, 392.00, 440.00, 392.00, 329.63, 392.00, 293.66, 329.63];
    let i = 0;

    const master = audioCtx.createGain();
    master.gain.value = 0.18;
    master.connect(audioCtx.destination);
    activeNodes.push(master);

    const playNote = (freq, durationMs) => {
      if (!audioCtx) return;
      const t0 = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(freq, t0);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(0.9, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + (durationMs / 1000));

      osc.connect(g);
      g.connect(master);

      osc.start(t0);
      osc.stop(t0 + (durationMs / 1000) + 0.03);

      activeNodes.push(osc, g);
    };

    soundTimer = setInterval(() => {
      playNote(seq[i % seq.length], 380);
      i++;
    }, 420);
  }

  async function startAlarmSound(){
    if (alarmActive) return;

    alarmActive = true;
    setUI();

    // Always do visual/vibration fallback first (more reliable on mobile)
    document.body.classList.add("alarm-flash");
    try { navigator.vibrate?.([250, 120, 250, 120, 400]); } catch {}

    try{
      await ensureAudio();
      if (soundMode === "beep") await startBeep();
      else await startLullaby();
    } catch (err){
      console.error("Alarm sound failed:", err);
      // keep alarmActive=true so overlay still shows "Stop sound" and alarm state remains visible
      alarmMsgEl.textContent += "\n\n(Sound may be blocked by this browser. Tap “Enable sound” first and keep app open.)";
    }

    setUI();
  }

  function stopAlarmSound(){
    stopAlarmNodes();
    alarmActive = false;
    clearAlarmAttention();
    setUI();
  }

  // ===== Background music =====
  function applyMusicSettings(){
    bgAudio.loop = (musicLoopEl.value === "on");
    bgAudio.volume = Number(musicVolEl.value || 0.25);
  }

  function setMusicUI(){
    const hasSrc = !!(bgAudio.getAttribute("src"));
    const playing = hasSrc && !bgAudio.paused;

    btnMusicPlay.disabled = playing;
    btnMusicPause.disabled = !playing;
    btnMusicStop.disabled = !hasSrc;

    musicStateEl.textContent = playing ? "Music: Playing" : (hasSrc ? "Music: Ready" : "Music: Off");
  }

  async function playMusic(){
    await unlockAudio(); // mobile unlock
    const url = musicTrackEl.value;
    if (!url) return;

    const cur = bgAudio.getAttribute("src") || "";
    if (cur !== url) bgAudio.setAttribute("src", url);

    applyMusicSettings();

    try {
      await bgAudio.play();
    } catch (err) {
      console.warn("Music play blocked:", err);
      alert("Browser blocked audio. Tap Enable sound, then Play again.");
    }

    setMusicUI();
  }

  function pauseMusic(){
    bgAudio.pause();
    setMusicUI();
  }

  function stopMusic(){
    bgAudio.pause();
    try { bgAudio.currentTime = 0; } catch {}
    setMusicUI();
  }

  function saveMusic(){
    saveJSON(LS_MUSIC, {
      track: musicTrackEl.value,
      loop: musicLoopEl.value,
      vol: Number(musicVolEl.value || 0.25)
    });
  }

  function restoreMusic(){
    const m = loadJSON(LS_MUSIC, "{}");
    if (m.track) musicTrackEl.value = m.track;
    if (m.loop) musicLoopEl.value = m.loop;
    if (typeof m.vol === "number") musicVolEl.value = String(m.vol);
    applyMusicSettings();
    setMusicUI();
  }

  // ===== Logs =====
  const loadLogs = () => loadJSON(LS_LOGS, "[]");
  const saveLogs = (logs) => saveJSON(LS_LOGS, logs);

  // ===== Overlay =====
  function showAlarmOverlay(title, msg, meta){
    alarmTitleEl.textContent = title || "⏰ Alarm";
    alarmMsgEl.textContent = msg || "Time to check feeding.";
    alarmMetaEl.textContent = meta || "";
    alarmOverlay.classList.add("show");
  }

  function hideAlarmOverlay(){
    alarmOverlay.classList.remove("show");
  }

  async function triggerAlarm(kind){
    const title = "⏰ Feeding Alarm";
    const msg = (kind === "oneShot")
      ? `It’s been ${oneShotMins} minutes since the last feed log.`
      : `Repeating reminder: every ${repeatMins} minutes.`;

    const meta =
`Time: ${new Date().toLocaleTimeString()}
Last feed: ${formatWhen(lastFeedAtMs)}
Since last feed: ${fmtHMS(getSinceMs())}`;

    showAlarmOverlay(title, msg, meta);
    await startAlarmSound();
    tryNotify(title, msg);
  }

  // ===== Scheduling =====
  function clearOneShot(){
    if (oneShotTimeoutId) clearTimeout(oneShotTimeoutId);
    oneShotTimeoutId = null;
    nextOneShotAtMs = 0;
  }

  function clearRepeat(){
    if (repeatTimeoutId) clearTimeout(repeatTimeoutId);
    repeatTimeoutId = null;
    nextRepeatAtMs = 0;
  }

  function scheduleOneShot(){
    clearOneShot();

    if (!running || !oneShotEnabled || !lastFeedAtMs) {
      setUI();
      return;
    }

    const ms = Math.max(1, oneShotMins) * 60 * 1000;
    nextOneShotAtMs = Date.now() + ms;

    oneShotTimeoutId = setTimeout(async () => {
      nextOneShotAtMs = 0;
      setUI();
      await triggerAlarm("oneShot");
    }, ms);

    setUI();
  }

  function scheduleRepeat(){
    clearRepeat();

    if (!running || !repeatEnabled) {
      setUI();
      return;
    }

    const ms = Math.max(1, repeatMins) * 60 * 1000;
    nextRepeatAtMs = Date.now() + ms;

    repeatTimeoutId = setTimeout(async function fire(){
      nextRepeatAtMs = 0;
      setUI();
      await triggerAlarm("repeat");

      if (running && repeatEnabled){
        nextRepeatAtMs = Date.now() + ms;
        setUI();
        repeatTimeoutId = setTimeout(fire, ms);
      }
    }, ms);

    setUI();
  }

  function rescheduleAll(){
    scheduleOneShot();
    scheduleRepeat();
  }

  // ===== Render =====
  function renderLogs(){
    const logs = loadLogs();

    if (!logs.length){
      listEl.innerHTML = `<div class="muted">No entries yet.</div>`;
      return;
    }

    listEl.innerHTML = logs.slice().reverse().map((x) => {
      const when = formatWhen(x.atMs);
      const interval = fmtHMS(x.intervalMs || 0);
      const note = x.note ? escapeHtml(x.note) : `<span class="muted">(no note)</span>`;

      return `
        <div class="item">
          <div class="itemTop">
            <div class="tag">${escapeHtml(x.type)} • ⏳ ${interval}</div>
            <div class="time">${when}</div>
          </div>
          <div class="note">${note}</div>
        </div>
      `;
    }).join("");
  }

  function renderSummary(){
    const logs = loadLogs();
    const todayKey = toLocalDateKey(Date.now());
    const todayLogs = logs.filter(x => toLocalDateKey(x.atMs) === todayKey);

    todayCountEl.textContent = String(todayLogs.length);

    if (!todayLogs.length){
      summaryBoxEl.innerHTML = `<div class="muted">No entries yet.</div>`;
      avgIntervalEl.textContent = "—";
      maxIntervalEl.textContent = "—";
      return;
    }

    const intervals = todayLogs.map(x => x.intervalMs).filter(ms => Number.isFinite(ms));
    const totalMs = intervals.reduce((a,b) => a + b, 0);
    const avgMs = Math.round(totalMs / Math.max(1, intervals.length));
    const maxMs = Math.max(...intervals);

    avgIntervalEl.textContent = fmtHMS(avgMs);
    maxIntervalEl.textContent = fmtHMS(maxMs);

    const counts = {};
    for (const x of todayLogs) counts[x.type] = (counts[x.type] || 0) + 1;

    const breakdown = Object.entries(counts)
      .sort((a,b) => b[1] - a[1])
      .map(([k,v]) => `${escapeHtml(k)}: <b>${v}</b>`)
      .join(" • ");

    const last = todayLogs[todayLogs.length - 1];
    const lastAt = last ? formatWhen(last.atMs) : "—";

    summaryBoxEl.innerHTML = `
      <div><b>Last log:</b> ${lastAt}</div>
      <div style="margin-top:6px;"><b>Average interval:</b> ${fmtHMS(avgMs)}</div>
      <div style="margin-top:6px;"><b>Longest interval:</b> ${fmtHMS(maxMs)}</div>
      <div style="margin-top:10px; color: var(--muted);">${breakdown}</div>
    `;
  }

  function renderAll(){
    setUI();
    renderSummary();
    renderLogs();
  }

  // ===== Save/restore state =====
  function saveState(){
    saveJSON(LS_STATE, { running, lastFeedAtMs });
  }

  function loadState(){
    return loadJSON(LS_STATE, "{}");
  }

  function saveAlarm(){
    saveJSON(LS_ALARM, { oneShotMins, oneShotEnabled, repeatMins, repeatEnabled, soundMode });
  }

  function loadAlarm(){
    return loadJSON(LS_ALARM, "{}");
  }

  function applyAlarmSettingsToUI(){
    oneShotMinsEl.value = String(oneShotMins);
    oneShotEnabledEl.value = oneShotEnabled ? "on" : "off";
    repeatMinsEl.value = String(repeatMins);
    repeatEnabledEl.value = repeatEnabled ? "on" : "off";
    soundModeEl.value = soundMode;
    setUI();
  }

  function readAlarmSettingsFromUI(){
    const os = Number(oneShotMinsEl.value || 0);
    const rp = Number(repeatMinsEl.value || 0);

    oneShotMins = Number.isFinite(os) && os >= 5 ? Math.round(os) : 120;
    repeatMins = Number.isFinite(rp) && rp >= 10 ? Math.round(rp) : 180;

    oneShotEnabled = (oneShotEnabledEl.value === "on");
    repeatEnabled = (repeatEnabledEl.value === "on");
    soundMode = (soundModeEl.value === "beep") ? "beep" : "lullaby";
  }

  // ===== Actions =====
  async function start(){
    await unlockAudio();         // user gesture unlock
    if (running) return;

    running = true;
    if (!lastFeedAtMs) lastFeedAtMs = Date.now();

    await enableWakeLock();      // keep screen awake where supported

    saveState();
    if (!rafId) tick();

    renderAll();
    rescheduleAll();
  }

  function logFeed(type){
    if (!running) return;

    const now = Date.now();
    const logs = loadLogs();

    const prevAt = lastFeedAtMs || now;
    const intervalMs = Math.max(0, now - prevAt);

    const typedNote = (noteEl.value || "").trim();
    const finalNote = [`[${type}]`, typedNote].filter(Boolean).join(" ");

    logs.push({ atMs: now, type, intervalMs, note: finalNote });
    saveLogs(logs);

    lastFeedAtMs = now;
    noteEl.value = "";
    saveState();

    renderAll();
    scheduleOneShot();
  }

  async function reset(){
    running = false;
    lastFeedAtMs = 0;

    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    sinceTimerEl.textContent = "00:00:00";

    clearOneShot();
    clearRepeat();
    stopAlarmSound();
    hideAlarmOverlay();
    await releaseWakeLock();

    saveState();
    renderAll();
  }

  function clearToday(){
    const logs = loadLogs();
    const todayKey = toLocalDateKey(Date.now());
    saveLogs(logs.filter(x => toLocalDateKey(x.atMs) !== todayKey));
    renderAll();
  }

  function clearAll(){
    localStorage.removeItem(LS_LOGS);
    renderAll();
  }

  // ===== Audio lifecycle fixes (important for mobile) =====
  async function tryResumeAudioContext(){
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      try { await audioCtx.resume(); } catch {}
    }
  }

  document.addEventListener("visibilitychange", async () => {
    if (!document.hidden) {
      await tryResumeAudioContext();
      if (running) await enableWakeLock();
    } else {
      // optional release; some browsers auto-release anyway
      // await releaseWakeLock();
    }
  });

  window.addEventListener("pageshow", async () => {
    await tryResumeAudioContext();
    if (running) await enableWakeLock();
  });

  // Auto-attempt unlock on first user interaction anywhere
  const unlockFromGesture = async () => {
    await unlockAudio();
    document.removeEventListener("pointerdown", unlockFromGesture);
    document.removeEventListener("touchstart", unlockFromGesture);
    document.removeEventListener("keydown", unlockFromGesture);
  };
  document.addEventListener("pointerdown", unlockFromGesture, { passive: true });
  document.addEventListener("touchstart", unlockFromGesture, { passive: true });
  document.addEventListener("keydown", unlockFromGesture);

  // ===== Events =====
  btnStart.addEventListener("click", start);
  btnLogNote.addEventListener("click", () => logFeed("Note"));
  btnReset.addEventListener("click", () => { reset(); });

  qBreast.addEventListener("click", () => logFeed("Breast"));
  qFormula.addEventListener("click", () => logFeed("Formula"));
  qBurp.addEventListener("click", () => logFeed("Diaper Changed"));
  qNote.addEventListener("click", () => logFeed("Note"));

  btnClearToday.addEventListener("click", clearToday);
  btnClearAll.addEventListener("click", clearAll);

  btnGoReminders.addEventListener("click", () => switchTab("reminders"));
  btnGoHistory.addEventListener("click", () => switchTab("history"));

  btnSaveAlarm.addEventListener("click", async () => {
    await unlockAudio(); // important for future alarms (best effort)
    readAlarmSettingsFromUI();
    saveAlarm();
    rescheduleAll();
    renderAll();
    alert("Saved ✅");
  });

  btnEnableNotif.addEventListener("click", async () => {
    const ok = await enableNotifications();
    alert(ok
      ? "Notifications enabled ✅"
      : "Notifications not enabled. The app will still use on-screen alarm + vibration.");
  });

  btnTestAlarm.addEventListener("click", async () => {
    await unlockAudio(); // user gesture
    readAlarmSettingsFromUI();
    renderAll();
    await triggerAlarm("oneShot");
  });

  btnStopAlarm.addEventListener("click", stopAlarmSound);

  btnOverlayStop.addEventListener("click", stopAlarmSound);
  btnOverlayDismiss.addEventListener("click", () => {
    stopAlarmSound();
    hideAlarmOverlay();
  });

  btnOverlaySnooze.addEventListener("click", () => {
    stopAlarmSound();
    hideAlarmOverlay();

    clearOneShot();
    const ms = 10 * 60 * 1000;

    nextOneShotAtMs = Date.now() + ms;
    oneShotTimeoutId = setTimeout(async () => {
      nextOneShotAtMs = 0;
      renderAll();
      await triggerAlarm("oneShot");
    }, ms);

    renderAll();
  });

  alarmOverlay.addEventListener("click", (e) => {
    if (e.target === alarmOverlay){
      stopAlarmSound();
      hideAlarmOverlay();
    }
  });

  // Music events
  btnEnableSound.addEventListener("click", async () => {
    const ok = await unlockAudio();
    alert(ok ? "Sound enabled ✅" : "Could not enable sound ❌");
  });

  btnMusicPlay.addEventListener("click", async () => { await playMusic(); saveMusic(); });
  btnMusicPause.addEventListener("click", () => { pauseMusic(); saveMusic(); });
  btnMusicStop.addEventListener("click", () => { stopMusic(); saveMusic(); });

  musicLoopEl.addEventListener("change", () => {
    applyMusicSettings();
    saveMusic();
    setMusicUI();
  });

  musicVolEl.addEventListener("input", () => {
    applyMusicSettings();
    saveMusic();
  });

  musicTrackEl.addEventListener("change", async () => {
    stopMusic();
    await playMusic();
    saveMusic();
  });

  bgAudio.addEventListener("play", setMusicUI);
  bgAudio.addEventListener("pause", setMusicUI);
  bgAudio.addEventListener("ended", setMusicUI);

  // ===== Restore =====
  const st = loadState();
  running = !!st.running;
  lastFeedAtMs = Number(st.lastFeedAtMs || 0);

  const al = loadAlarm();
  oneShotMins = Number(al.oneShotMins || 120);
  oneShotEnabled = (al.oneShotEnabled ?? true) === true;
  repeatMins = Number(al.repeatMins || 180);
  repeatEnabled = (al.repeatEnabled ?? false) === true;
  soundMode = (al.soundMode === "beep") ? "beep" : "lullaby";

  applyAlarmSettingsToUI();
  restoreMusic();
  renderAll();

  // Clock + timer
  updateClock();
  setInterval(updateClock, 1000);

  if (running){
    if (!lastFeedAtMs) lastFeedAtMs = Date.now();
    saveState();
    if (!rafId) tick();
    enableWakeLock();
    rescheduleAll();
  } else {
    sinceTimerEl.textContent = "00:00:00";
    clearOneShot();
    clearRepeat();
  }

  // ===== Service worker =====
  if ("serviceWorker" in navigator){
    window.addEventListener("load", async () => {
      try {
        await navigator.serviceWorker.register("./service-worker.js");
        installState.textContent = "Offline-ready";
      } catch {
        installState.textContent = "SW failed";
      }
    });
  }
})();
</script>
